# Summary

# Contents

---

# 1ì¥

## Agile ì„ ì–¸ë¬¸ âœ‹

> â€¢ **Individuals and interactions** over processes and tools
â€¢ **Working software over** comprehensive documentation
â€¢ **Customer collaboration** over contract negotiation
â€¢ **Responding to change** over following a plan
> 

## 12ê°€ì§€ ì›ì¹™ ğŸ“‘

1. ì˜ìš•ì  ê°œì¸ë“¤ ì¤‘ì‹¬ìœ¼ë¡œ í™˜ê²½ê³¼ í•„ìš”ë¡œí•˜ëŠ” ìì›ì„ ì œê³µí•˜ê³  ë¯¿ê³  ë§¡ê²¨ë¼.
2. íš¨ìœ¨ì ì¸ ì •ë³´ ì „ë‹¬ë²•ì€ ì¼ëŒ€ì¼ëŒ€í™”ì´ë‹¤.
3. ì§€ì†ì ì¸ ì†ë„ ìœ ì§€ë¡œ ì§€ì†ê°€ëŠ¥í•œ ê°œë°œì„ ì´‰ì§„í•œë‹¤.
4. ìš°ìˆ˜ê¸°ìˆ ê³¼ ì¢‹ì€ ì„¤ê³„ì— ëŒ€í•œ ì§€ì†ì  ê´€ì‹¬ì€ ì†ë„ë¥¼ í–¥ìƒí•œë‹¤.
5. ë‹¨ìˆœì„±ì€ í•„ìˆ˜ì ì´ë‹¤.
6. ì§€ì†ì ì¸ ê³µê°œë¥¼ í†µí•´ ê³ ê°ì„ ë§Œì¡±ì‹œì¼œë¼
7. ë” ì§§ì€ ì‹œê°„ ê°„ê²©ìœ¼ë¡œ ìì£¼ ê³µê°œí•´ë¼
8. ê°œë°œ ì¤‘ì¸ ì†Œí”„íŠ¸ì›¨ì–´ê°€ ì§„ì²™ìƒí™©ì˜ ì¼ì°¨ ì²™ë„ì´ë‹¤
9. ë¹„ì¦ˆë‹ˆìŠ¤ë§¨ê³¼ ê°œë°œìëŠ” í•¨ê»˜ ì¼í•´ì•¼í•œë‹¤.
10. ìš”êµ¬ì‚¬í•­ ë³€ê²½ì„ í™˜ì˜í•´ë¼
11. ìµœê³ ì˜ ì•„í‚¤í…ì²˜,ìš”êµ¬ì‚¬í•­,ì„¤ê³„ëŠ” ìê¸°ì¡°ì§ì ì¸ íŒ€ì—ì„œ ë‚˜ì˜¨ë‹¤.
12. íŒ€ì€ ë” íš¨ê³¼ì ì¸ ë°©ë²•ì„ ê·œì¹™ì ìœ¼ë¡œ ë°˜ì˜í•˜ê³  ì¡°ìœ¨í•˜ê³  ì¡°ì •í•œë‹¤.

---

# 2ì¥

## XPë°©ë²• ğŸ’¼

- ê³ ê° íŒ€ êµ¬ì„±ì›

ê³ ê°ì—ê²Œ ìˆì–´ ìµœì„ ì˜ ìƒí™©ì€ ê°œë°œìì™€ ê°™ì€ ê³µê°„ì—ì„œ ì¼í•˜ë©°, ì„œë¡œì˜ ë¬¸ì œë¥¼ ì¸ì‹í•˜ê³  ì´ë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ ë…¸ë ¥í•´ì•¼í•œë‹¤.

- ì‚¬ìš©ì ìŠ¤í† ë¦¬

ê³ ê°ì´ ê°™ì´ í•©ì˜í•˜ì—¬ ì •í•œ ìƒ‰ì¸ì¹´ë“œì— ëª‡ ê°œì˜ ë‹¨ì–´ë¥¼ ì ìœ¼ë©´, ê°œë°œìëŠ” ê³ ê°ê³¼ì˜ ëŒ€í™”ë¥¼ ì¶”ì •í•œ ë‚´ìš©ì„ ì¹´ë“œì— ê¸°ë¡í•œë‹¤. ì‚¬ìš©ì ìŠ¤í† ë¦¬ë€ í˜„ì¬ ì§„í–‰ ì¤‘ì¸ ìš”êµ¬ì‚¬í•­ì— ê´€í•œ ëŒ€í™”ì˜ ì—°ìƒê¸°í˜¸ë¡œì„œ, ìš”êµ¬ì‚¬í•­ êµ¬í˜„ ì¼ì •ì„ ìˆ˜ë¦½í•˜ê²Œ í•´ì£¼ëŠ” ê³„íš íˆ´ì´ë‹¤

- ë©”íƒ€í¬
- ì›Œí¬ìŠ¤í˜ì´ìŠ¤
- ì§§ì€ ë°˜ë³µ
- TDD
- ë¦¬íŒ©í† ë§
- ë‹¨ìˆœí•œ ì„¤ê³„
    - ì–´ë–»ê²Œë“  ë™ì‘í•˜ëŠ” ê°€ì¥ ë‹¨ìˆœí•œ ê²ƒ
    - í•„ìš”í•˜ì§€ ì•Šì„ ê²ƒì´ë¼ëŠ” ê°€ì •í•˜ì— ì‹œì‘
    - ì½”ë“œ ì¤‘ë³µ ì§€ì–‘
- ê³„íšì„¸ìš°ê¸° ê²Œì„
- ì§€ì†ì†ë„
- ì§€ì†ì í†µí•© : push(),pull(),merge()
- ê³µë™ ì†Œìœ  : ì–´ëŠëˆ„êµ¬ë“  ì–´ë–¤ ëª¨ë“ˆì´ë“  ì ê²€,ê°œì„ 
- ì¸ìˆ˜í…ŒìŠ¤íŠ¸ : ì‚¬ìš©ììŠ¤í† ë¦¬ì— ë”°ë¥¸ ì‹¤í–‰ì—¬ë¶€ í™•ì¸

---

# 3ì¥

## ê³„íšì„¸ìš°ê¸° ğŸ—“ï¸

1. ì´ˆê¸° íƒìƒ‰ : User Storyì—ì„œ point ì ê¸°
2. Spike Prototype : ìŠ¤í† ë¦¬ í¬ì¸íŠ¸ ìˆ˜ë¥¼ í†µí•´ ì†ë„ ì¸¡ì •
3. ë¦´ë¦¬ì¦ˆ ê³„íš ì„¸ìš°ê¸° : ìš°ì„ ìˆœìœ„,ì‚¬ì—…ê°€ì¹˜,ë¹„ìš© ë“±ë“±ì„ ë”°ì ¸ ìŠ¤í† ë¦¬ êµ¬í˜„ìˆœì„œ ì„ íƒ
4. ë°˜ë³µ ê³„íš ì„¸ìš°ê¸° : ë°˜ë³µ í¬ê¸° ì„ íƒ, ì´ì „ ë°˜ë³µ ì†ë„ ê³„ì‚°í•˜ì—¬ ë‹¤ìŒ ë°˜ë³µ ì†ë„ ì¸¡ì •
5. íƒœìŠ¤í¬ ê³„íš ì„¸ìš°ê¸° : ìŠ¤í† ë¦¬ ë¶„í• í•˜ì—¬ ê°œë°œ íƒœìŠ¤í¬ë¡œ ë§Œë“¤ê³ , ê° ê°œì¸ ì˜ˆì‚°ì— ë§ì¶° êµ¬í˜„í•˜ë ¤ëŠ” íƒœìŠ¤í¬ì— ê°ì ì°¸ì—¬
- *ì›ë¬¸ì—ì„œ ë§í•˜ëŠ” Task Pointì™€ Story PointëŠ” ë¬´ìŠ¨ ì°¨ì´ì ì´ ìˆì„ê¹Œ?*
    
    [Story Points vs Task Points](Summary%207cccff5a119840859a6841d893716f9f/Story%20Points%20vs%20Task%20Points%2026b551542d034466bfa6c19e9124c187.md)
    
1. ë°˜í™˜ì  : ë°˜ë³µì´ ë°˜ ì¯¤ ì™”ì„ ë•Œ, ì™„ë£Œë˜ì–´ ìˆì§€ ì•Šë‹¤ë©´ íƒœìŠ¤í¬ì™€ ì±…ì„ ì¬ë¶„ë°°
2. ë°˜ë³µ : ë°˜ë³µì´ ëë‚˜ê³  ë‹¤ìŒ ë°˜ë³µì´ ì§„í–‰ë˜ê³ , ê° ë°˜ë³µì˜ ë§ˆì§€ë§‰ì—ëŠ” ë™ì‘ê°€ëŠ¥ë¶€ë¶„ì„ ê³ ê° ì•ì—ì„œ ì‹œì—° ì´í›„ í”¼ë“œë°± ì œê³µ

---

# 4ì¥

## TDDì˜ íš¨ê³¼

1. ëª¨ë“  ë‹¨ì¼í•¨ìˆ˜ê°€ ê²€ì¦í…ŒìŠ¤íŠ¸ë¥¼ ê°€ì§€ê²Œ ëœë‹¤
2. ê°œë°œìëŠ” í˜¸ì¶œì ê´€ì ì—ì„œ í•¨ìˆ˜ë§Œí¼ì´ë‚˜ ì¸í„°í˜ì´ìŠ¤ì—ë„ ê´€ì‹¬ì„ ê°€ì§€ê²Œ ë˜ì–´, í¸ë¦¬í•˜ê²Œ í˜¸ì¶œí•  ìˆ˜ ìˆëŠ” SWë¥¼ ì„¤ê³„í•  ìˆ˜ ìˆë‹¤.
3. í…ŒìŠ¤íŠ¸ ê°€ëŠ¥í•œ í”„ë¡œê·¸ë¨ ì„¤ê³„í•˜ë„ë¡ ê°•ì œí•  ìˆ˜ ìˆë‹¤. ì´ì— ë”°ë¼ SWë¥¼ ë‹¤ë¥¸ í™˜ê²½ê³¼ ë¶„ë¦¬í•˜ë„ë¡ ê°•ì œí•œë‹¤
4. í…ŒìŠ¤íŠ¸ê°€ ë¬¸ì„œí™”ì˜ ê·€ì¤‘í•œ í•œ í˜•íƒœë¡œ ê¸°ëŠ¥í•  ìˆ˜ ìˆë‹¤. í•¨ìˆ˜ í˜¸ì¶œ ë° ê°ì²´ ìƒì„±ë²•ì— ëŒ€í•´ ë³´ì—¬ì¤„ ìˆ˜ ìˆëŠ” ì˜ˆì‹œë¥¼ ë“¤ ìˆ˜ ìˆë‹¤.

## í…ŒìŠ¤íŠ¸ ë¶„ë¦¬ ğŸ“

![Untitled](Summary%207cccff5a119840859a6841d893716f9f/Untitled.png)

ìœ„ SWì—ëŠ” ê²€ì¦ì— ëŒ€í•œ ë¬¸ì œê°€ ìˆë‹¤.

- ì–´ë–¤ DBë¥¼ ì‚¬ìš©í•  ê²ƒì¸ê°€?
- Payroll í´ë˜ìŠ¤ë¥¼ í…ŒìŠ¤íŠ¸í•˜ê¸°ë„ ì „ì— ì™„ë²½í•œ ê¸°ëŠ¥ì„ ê°–ì¶˜ DBë¥¼ ì‘ì„±í•´ì•¼í•œë‹¤.
- DBì— ì–´ë–¤ ë°ì´í„°ë¥¼ ë¡œë“œí•  ê²ƒì¸ê°€
- ì ì ˆí•œ ìˆ˜í‘œê°€ ì¶œë ¥ë˜ëŠ” ì§€ ê²€ì¦í•  ìˆ˜ ì—†ë‹¤.
- ì¶œë ¥ìˆ˜í‘œë¥¼ ë³´ê³  ì•¡ìˆ˜ë¥¼ í™•ì¸í•˜ëŠ” ìë™í™” í…ŒìŠ¤íŠ¸ë¥¼ ì‘ì„±í•˜ëŠ” ê²ƒì€ ë¶ˆê°€ëŠ¥í•˜ë‹¤.

ì´ì— ë”°ë¼ MOCK OBJECT íŒ¨í„´, ì¦‰ ì˜ì‚¬ê°ì²´ íŒ¨í„´ì„ ì´ìš©í•œë‹¤.

Payrollì˜ ëª¨ë“  ê´€ë ¨ ìš”ì†Œ ì‚¬ì´ì‚¬ì´ì— ì¸í„°í˜ì´ìŠ¤ë¥¼ ì¶”ê°€í•˜ê³  ì´ ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„í•˜ëŠ” í…ŒìŠ¤íŠ¸ ìŠ¤í…(stub)ì„ ìƒì„±í•œë‹¤.

![Untitled](Summary%207cccff5a119840859a6841d893716f9f/Untitled%201.png)

ì´ì™€ ê°™ì´ ì„¤ê³„í•˜ê²Œ ë˜ë©´, Payrollì€ ë‹¤ë¥¸ ê°ì²´(Employee,CheckWriter)ì™€ ë¶„ë¦¬ê°€ ë˜ê²Œ ëœë‹¤. ì´ë ‡ê²Œ í…ŒìŠ¤íŠ¸ë¥¼ ë¨¼ì € ì‘ì„±í•˜ê²Œ ë˜ë©´ ì˜ì¡´ì„±ì„ ê´€ë¦¬í•  ìˆ˜ ìˆë‹¤.

ì•„ë˜ëŠ” ìœ„ í…ŒìŠ¤íŠ¸ê°€ ë‚´í¬í•˜ëŠ” ì˜ë„ë¥¼ ë³´ì—¬ì¤€ë‹¤.

1. ì ì ˆí•œ ì˜ì‚¬ ê°ì²´ë¥¼ ìƒì„±
2. Payroll â† ìƒì„±í•œ ì˜ì‚¬ê°ì²´ 
3. Payroll ê°ì²´ì—ê²Œ ëª¨ë“  ì§ì›ì˜ ì„ê¸ˆì„ ì§€ë¶ˆí•˜ë¼ê³  ëª…ë ¹
4. ëª¨ë“  ìˆ˜í‘œê°€ ì˜¬ë°”ë¥´ê²Œ ì‘ì„±ëëŠ”ì§€ ê²€ì¦ ìš”ì²­
5. ëª¨ë“  ì„ê¸ˆì´ ì˜¬ë°”ë¥´ê²Œ ì§€ê¸‰ëëŠ”ì§€ ê²€ì¦ ìš”ì²­

```java
public void testPayroll()
{
 MockEmployeeDatabase db = new MockEmployeeDatabase();
 MockCheckWriter w = new MockCheckWriter();
 Payroll p = new Payroll(db, w);
 p.payEmployees();
 assert(w.checksWereWrittenCorrectly());
 assert(db.paymentsWerePostedCorrectly());
}
```

## ì¸ìˆ˜í…ŒìŠ¤íŠ¸ ğŸ¤

- ë‹¨ìœ„í…ŒìŠ¤íŠ¸ : ì‹œìŠ¤í…œ ê°œë³„ ë©”ì»¤ë‹ˆì¦˜ì„ ê²€ì¦í•˜ëŠ” í™”ì´íŠ¸ë°•ìŠ¤ í…ŒìŠ¤íŠ¸
- ì¸ìˆ˜í…ŒìŠ¤íŠ¸ : ê³ ê° ìš”êµ¬ì‚¬í•­ì´ ì¶©ì¡±ë˜ëŠ”ì§€ë¥¼ ê²€ì¦í•˜ëŠ” ë¸”ë™ë°•ìŠ¤ í…ŒìŠ¤íŠ¸

ì¸ìˆ˜í…ŒìŠ¤íŠ¸ëŠ” ì‹œìŠ¤í…œì˜ ê¸°ëŠ¥ìš”ì†Œì˜ ê¶ê·¹ì ì¸ ë¬¸ì„œí™” í˜•íƒœë¡œ, ì»´íŒŒì¼ê°€ëŠ¥í•˜ê³  ì‹¤í–‰ê°€ëŠ¥í•œ ë¬¸ì„œë¡œì˜ ì—­í• ì„ ìˆ˜í–‰í•œë‹¤*.*

> *So, just as unit tests serve as compileable and executable documentation for the internals of the system, **acceptance tests serve as compileable and executable documentation of the features of the system.**
- Agile Software Development, Principles, Patterns, and Practices: Pearson New International Edition P.34 -*
> 

## ì¸ìˆ˜í…ŒìŠ¤íŠ¸ ì˜ˆì œ

```jsx
AddEmp 1429 "Robert Martin" 3215.88          // add Emp to DB
Payday                                       // tell system today is the payday
Verify Paycheck EmpId 1429 GrossPay 3215.88  // verify whether id:1429's gross pay is 3215.88
```

1. ì§ì›ë²ˆí˜¸ 1429 , ì´ë¦„ â€œRobert Martinâ€, ì›”ê¸‰ì€ 3215.88ë‹¬ëŸ¬
2. ì‹œìŠ¤í…œì—ê²Œ ì˜¤ëŠ˜ì´ ì›”ê¸‰ë‚ ì´ë©° ëª¨ë“  ì§ì›ì—ê²Œ ì›”ê¸‰ì„ ì£¼ì–´ì•¼í•œë‹¤ê³  ëª…ë ¹
3. 1429ë²ˆ ì§ì›ì˜ ì§€ê¸‰ìˆ˜í‘œê°€ GrossPay(ì´ì•¡) í•„ë“œì— 3215.88ë‹¬ëŸ¬ë¡œ ìƒì„±ë˜ì—ˆëŠ”ì§€ í™•ì¸

ì²« ë‘ ë¼ì¸ì€ ê¸‰ì—¬ê´€ë¦¬ì˜ ê¸°ëŠ¥ìœ¼ë¡œì„œ, payroll transactionì„ ìˆ˜í–‰í•˜ë©°

ì„¸ ë²ˆì§¸ ë¼ì¸ì€ ê¸‰ì—¬ê´€ë¦¬ ì‚¬ìš©ìê°€ ê¸°ëŒ€í•œ transactionì´ ì•„ë‹Œ, ê²€ì¦ì„ ìˆ˜í–‰í•˜ëŠ” ì§€ì‹œì–´(directive)ì´ë‹¤.

ì‹œìŠ¤í…œì€ payroll transactionì„ ì‚¬ìš©ìë¡œë¶€í„° ë”°ë¡œ ì…ë ¥ë°›ê³ , ì¸ìˆ˜í…ŒìŠ¤íŠ¸ í”„ë ˆì„ì›Œí¬ë¡œë¶€í„° directiveë¥¼ ë”°ë¡œ ì…ë ¥ë°›ëŠ”ë‹¤. ì´ëŠ” ì‹œìŠ¤í…œì— êµ‰ì¥í•œ ì••ë°•(stress)ë¥¼ ì£¼ê²Œ ëœë‹¤.

ë”°ë¼ì„œ payroll transactionê³¼ directiveë¥¼ ë¶„ë¦¬í•´ì•¼í•  í•„ìš”ê°€ ìˆë‹¤.

ì´ì— ë”°ë¥¸ í•´ê²°ì±…ì€ transactionê³¼ directive ê°ê°ì„ XMLí˜•ì‹ìœ¼ë¡œ ìƒì„±í•˜ëŠ” ê²ƒì´ë‹¤.

**# transaction** 

```xml
<AddEmp PayType=Salaried>
		<EmpId>1429</EmpId>
		<Name>Robert Martin</Name>
		<Salary>3215.88</Salary>
</AddEmp>
```

**# directive** 

```xml
<Paycheck>
		<EmpId>1429</EmpId>
		<Name>Robert Martin</Name>
		<GrossPay>3215.88</GrossPay>
</Paycheck>
```

ì´ëŸ¬í•œ XMLí˜•ì‹ì„ í†µí•´ í˜¸ì¶œ,ì†Œì¼“,ë°°ì¹˜ ì…ë ¥íŒŒì¼ì„ í†µí•´ ì…ë ¥,ì¶œë ¥,ì½ê¸° ëª¨ë‘ ê°€ëŠ¥í•˜ê²Œ ëœë‹¤.

# ë¦¬íŒ©í† ë§ âš™ï¸

ë¦¬íŒ©í† ë§ì´ë€ ë‹¤ìŒê³¼ ê°™ì´ ì •ì˜ëœë‹¤.

> **Process of changing sw does not alter external behavior of the code yet improves its external structure**
- *Martin Fowler"Refactoring: Improving the Design of Existing Code,"Addison-Wesley, 1999, p. xvi*
> 

ì €ì ë°¥ ì•„ì €ì”¨ëŠ” ì´ ì±…ì„ í†µí•´ ë‹¤ìŒê³¼ ë§í•œë‹¤.

> ëª¨ë“ˆì„ ì½ê¸° ì‰½ê²Œ ë§Œë“¤ë ¤ë©´ ë¬´ì—‡ì´ í•„ìš”í• ê¹Œ? ì›ì¹™ê³¼ íŒ¨í„´ì„ ì„¤ëª…í•˜ëŠ” ê²ƒë„ ì¤‘ìš”í•˜ì§€ë§Œ, ë” ì½ê¸° ì‰½ê³  ë³€ê²½í•˜ê¸° ì‰½ê²Œ ë§Œë“¤ê¸° ìœ„í•´ì„œëŠ” ê·¸ ì´ìƒì˜ ê²ƒì´ í•„ìš”í•˜ë‹¤. ê·¸ê²ƒì€ ë°”ë¡œ ì£¼ì˜ë ¥ê³¼ í›ˆë ¨ì´ë‹¤. ë¯¸ë¥¼ ì°½ì¡°í•˜ê¸° ìœ„í•œ ì—´ì •ì´ í•„ìš”í•˜ë‹¤.
> 

## ë¦¬íŒ©í† ë§ì€ ì´ë ‡ê²Œ í•˜ëŠ” ê±°ë‹¤ : Prime Generator

---

## ver1

---

```java
import java.util.*;
public class GeneratePrimes
{
 /**
 * @param maxValue is the generation limit.
 */
 public static int[] generatePrimes(int maxValue)
 {
 if (maxValue >= 2) // the only valid case
	 {
	 // declarations
	 int s = maxValue + 1; // size of array
	 boolean[] f = new boolean[s];
	 int i;

	 // initialize array to true.
	 for (i = 0; i < s; i++)
		 f[i] = true;
	 
	 // get rid of known non-primes
	 f[0] = f[1] = false;

	 // sieve
	 int j;
	 for (i = 2; i < Math.sqrt(s) + 1; i++)
	 {
		 if (f[i]) // if i is uncrossed, cross its multiples.
		 {
		 for (j = 2 * i; j < s; j += i)
			 f[j] = false; // multiple is not prime
		 }
	 }

	 // how many primes are there?
	 int count = 0;
	 for (i = 0; i < s; i++)
	 {
		 if (f[i])
		 count++; // bump count.
	 }

	 int[] primes = new int[count];

	 // move the primes into the result
	 for (i = 0, j = 0; i < s; i++)
	 {
		 if (f[i]) // if prime
			 primes[j++] = i;
	 }

	 return primes; // return the primes
	 } else // maxValue < 2
			return new int[0]; // return null array if bad input.
 }
```

## ver2

---

```java
import java.util.*;
public class PrimeGenerator
{
 **private static int s;
 private static boolean[] f;
 private static int[] primes;**
 public static int[] generatePrimes(int maxValue)
 {
	 if (maxValue < 2)
		 return new int[0];
	 else
	 {
		 **initializeSieve(maxValue);
		 sieve();
		 loadPrimes();**
		 return primes; // return the primes
	 }
 }

 private static void loadPrimes()
 {
	 int i;
	 int j;

	 // how many primes are there?
	 int count = 0;
	 for (i = 0; i < s; i++)
	 {
		 if (f[i])
			 count++; // bump count.
	 }
	 primes = new int[count];

	 // move the primes into the result
	 for (i = 0, j = 0; i < s; i++)
	 {
		 if (f[i]) // if prime
		 primes[j++] = i;
	 }
 }

 private static void sieve()
 {
	 int i;
	 int j;
	 for (i = 2; i < Math.sqrt(s) + 1; i++)
	 {
		 if (f[i]) // if i is uncrossed, cross out its multiples.
		 {
			 for (j = 2 * i; j < s; j += i)
				 f[j] = false; // multiple is not prime
		 }
	 }
 }

 private static void initializeSieve(int maxValue)
 {
	 // declarations
	 s = maxValue + 1; // size of array
	 f = new boolean[s];
	 int i;
	 // initialize array to true.
	 for (i = 0; i < s; i++)
		 f[i] = true;
	 // get rid of known non-primes
	 f[0] = f[1] = false;
 }
}
```

## ver3

---

```java
public class PrimeGenerator
{
	private static boolean[] f;
	private static int[] **result**; // <- int[] primes
	public static int[] generatePrimes(int maxValue)
	{
		if (maxValue < 2)
			return new int[0];
		else
		{
			**initializeArrayOfIntegers(maxValue); // initializeSieve()
			crossOutMultiples(); // sieve()
			putUncrossedIntegersIntoResult(); // loadPrimes()**
			return **result**;
		}
 }
 private static void **initializeArrayOfIntegers**(int maxValue)
 {
	f = new boolean[maxValue + 1];
	f[0] = f[1] = false; //neither primes nor multiples.
	for (int i = 2; i < **f.length**; i++)
		f[i] = true;
 }
```

## ver4

---

```java
public class PrimeGenerator
{
 private static boolean[] isCrossed;
 private static int[] result;
 public static int[] generatePrimes(int maxValue)
 {
	 if (maxValue < 2)
		 return new int[0];
	 else
	 {
		 initializeArrayOfIntegers(maxValue);
		 crossOutMultiples();
		 putUncrossedIntegersIntoResult();
		 return result;
	 }
 }
 private static void initializeArrayOfIntegers(int maxValue)
 {
	 **isCrossed = new boolean[maxValue + 1];
	 /* ~~f[0] = f[1] = false;** //neither primes nor multiples.*/~~
****	 for (int i = 2; i < isCrossed.length; i++)
		 **isCrossed[i] = false; // <-** f[i] = true;
**** }
 **private static void crossOutMultiples()
 {
	 int maxPrimeFactor = calcMaxPrimeFactor();
	 for (int i = 2; i <= maxPrimeFactor; i++)
		 if (notCrossed(i))
			 crossOutMultiplesOf(i);
 }
 private static int calcMaxPrimeFactor()
 {
	 // We cross out all multiples of p, where p is prime.
	 // Thus, all crossed out multiples have p and q for
	 // factors. If p > sqrt of the size of the array, then
	 // q will never be greater than 1. Thus p is the
	 // largest prime factor in the array, and is also
	 // the iteration limit.
	 double maxPrimeFactor = Math.sqrt(isCrossed.length) + 1;
	 return (int) maxPrimeFactor;
 }
 private static void crossOutMultiplesOf(int i)
 {
	 for (int multiple = 2*i; multiple < isCrossed.length; multiple += i)
		 isCrossed[multiple] = true;
 }
 private static boolean notCrossed(int i)
 {
	 return isCrossed[i] == false;
 }
}**
```

## ver5

---

```java
**private static void putUncrossedIntegersIntoResult()
{
	result = new int[numberOfUncrossedIntegers()];
	for (int j = 0, i = 2; i < isCrossed.length; i++)
		if (notCrossed(i)) //ì§€ì›Œì§€ì§€ ì•Šì€ ì •ìˆ˜ë¥¼
			result[j++] = i;   // ê²°ê³¼ë°°ì—´ì— ì…ë ¥
	}
private static int numberOfUncrossedIntegers()
{
	int count = 0;
	for (int i = 2; i < isCrossed.length; i++)
		if (notCrossed(i)) // ì§€ì›Œì§€ì§€ ì•Šì€ ì •ìˆ˜ë¥¼
			count++;            // count~!
	return count;
}**
```

## final

---

```java
public class PrimeGenerator
{
 private static boolean[] **crossedOut**;
 private static int[] result;
 public static int[] generatePrimes(int maxValue)
 {
	 if (maxValue < 2)
		 return new int[0];
	 else
	 {
		 **uncrossIntegersUpTo(maxValue);**
		 crossOutMultiples();
		 putUncrossedIntegersIntoResult();
		 return result;
	 }
	 }
	private static void **uncrossIntegersUpTo**(int maxValue)
	{
		**crossedOut = new boolean[maxValue + 1];**
		for (int i = 2; i < crossedOut.length; i++)
			crossedOut[i] = false;
	}
	private static void crossOutMultiples()
	{
		int limit = determineIterationLimit();
		for (int i = 2; i <= limit; i++)
			if (notCrossed(i))
				crossOutMultiplesOf(i);
	}
 **private static int determineIterationLimit()
 {
	 // Every multiple in the array has a prime factor that
	 // is less than or equal to the sqrt of the array size,
	 // so we don't have to cross out multiples of numbers
	 // larger than that root.
	 double iterationLimit = Math.sqrt(crossedOut.length);
	 return (int) iterationLimit;
 }**
 private static void crossOutMultiplesOf(int i)
 {
	 for (int multiple = 2*i; multiple < crossedOut.length; multiple += i)
		 crossedOut[multiple] = true;
 }
 private static boolean notCrossed(int i)
 {
	 return crossedOut[i] == false;
 }
 private static void putUncrossedIntegersIntoResult()
 {
	 result = new int[numberOfUncrossedIntegers()];
	 for (int j = 0, i = 2; i < crossedOut.length; i++)
		 if (notCrossed(i))
			 result[j++] = i;
 }
 private static int numberOfUncrossedIntegers()
 {
	 int count = 0;
		 for (int i = 2; i < crossedOut.length; i++)
			 if (notCrossed(i))
				 count++;
	 return count;
 }
}
```

# Bowling Game

---

[Bowling Game](Bowling%20Game%2043113191dd22445baf440b9137dfddbd.md)

# ì„¤ê³„ ì•…ì·¨

---

- ê²½ì§ì„± : ë‹¨ìˆœí•œ ë°©ë²•ìœ¼ë¡œë„ ì†Œí”„íŠ¸ì›¨ì–´ë¥¼ ë³€ê²½í•˜ê¸° ì–´ë ¤ìš´ ê²½í–¥
- ì·¨ì•½ì„± : í•œ êµ°ë°ë¥¼ ë³€ê²½í–ˆì„ ë•Œ í”„ë¡œê·¸ë¨ì˜ ë§ì€ ë¶€ë¶„ì´ ì˜ëª»ë˜ëŠ” ê²½í–¥
- ë¶€ë™ì„± : ë‹¤ë¥¸ ì‹œìŠ¤í…œì—ì„œ ìœ ìš©í•˜ê²Œ ì“¸ ìˆ˜ ìˆëŠ” ë¶€ë¶„ì„ í¬í•¨í•˜ê³  ìˆì§€ë§Œ, ê·¸ëŸ° ë¶€ë¶„ì„ ì›ë˜ ì‹œìŠ¤í…œì—ì„œ ë¶„ë¦¬í•˜ëŠ” ìˆ˜ê³ ì™€ ìœ„í—˜ì„±ì´ ì§€ë‚˜ì¹˜ê²Œ í´ ë•Œ ì„¤ê³„ëŠ” ì›€ì§ì´ê²Œ í•  ìˆ˜ ì—†ìŒ
- ì ì°©ì„± : ì†Œí”„íŠ¸ì›¨ì–´ì˜ ì„¤ê³„ë¥¼ ìœ ì§€í•˜ê¸° ì–´ë ¤ìš¸ ë•Œ
    - ì„¤ê³„ì˜ ì ì°©ì„± : ì„¤ê³„ ìœ ì§€ ë°©ë²•ì´ ì—‰í„°ë¦¬ ë°©ë²•ë³´ë‹¤ ì‚¬ìš©í•˜ê¸° ì–´ë ¤ìš¸ ë•Œ
    â†’ ì˜ëª»ëœ ë™ì‘ì„ í•˜ê¸°ëŠ” ì‰½ì§€ë§Œ, ì˜³ì€ ë™ì‘ì„ í•˜ê¸°ëŠ” ì–´ë µë‹¤.
    - í™˜ê²½ì˜ ì ì°©ì„± : ê°œë°œí™˜ê²½ì´ ëŠë¦¬ê³  ë¹„íš¨ìœ¨ì ì¼ ë•Œ  ë°œìƒ
- ë¶ˆí•„ìš”í•œ ë³µì¡ì„± : í˜„ì¬ ì‹œì ì—ì„œ ìœ ìš©í•˜ì§€ ì•Šì€ ìš”ì†Œê°€ ì„¤ê³„ì— í¬í•¨ë˜ì–´ ìˆì„ ë•Œ ë°œìƒ
    
    â†’ ê°œë°œìê°€ ìš”êµ¬ì‚¬í•­ì— ëŒ€í•œ ë³€ê²½ì„ ë¯¸ë¦¬ ì˜ˆìƒí•˜ê³ , ì ì¬ì ì¸ ë³€ê²½ì„ ì²˜ë¦¬í•˜ê¸° ìœ„í•´ ì†Œí”„íŠ¸ì›¨ì–´ì— ê¸°ëŠ¥ì„ ì§‘ì–´ë„£ì„ ë•Œ ë°œìƒí•¨.
    
- ë¶ˆí•„ìš”í•œ ë°˜ë³µ : â€˜ë³µì‚¬í•˜ê¸°â€™ì™€ â€˜ë¶™ì—¬ë„£ê¸°â€™ë¥¼ í†µí•´ ì†Œí”„íŠ¸ì›¨ì–´ ì‹œìŠ¤í…œì´ ë°˜ë³µëœ ì½”ë“œ ìš”ì†Œë¡œ êµ¬ì„±ë  ë•Œ
â†’ ì‹œìŠ¤í…œì— ë°˜ë³µë˜ëŠ” ì½”ë“œê°€ ì¡´ì¬í•  ë•Œ, ì‹œìŠ¤í…œì„ ë³€ê²½í•˜ëŠ” ì¼ì€ ê³ ë  ìˆ˜ ìˆìŒ.
- ë¶ˆíˆ¬ëª…ì„± : ëª¨ë“ˆì„ ì´í•´í•˜ê¸° ì–´ë ¤ìš´ ê²½í–¥
â†’ ê°œë°œìëŠ” ì½ëŠ” ì‚¬ëŒì˜ì…ì¥ì—ì„œ ìƒê°í•˜ê³  ì½”ë“œë¥¼ ëª…ë£Œí•˜ê³  í‘œí˜„ì ìœ¼ë¡œ ìœ ì§€í•˜ë ¤ëŠ” ì§€ì†ì ì¸ ë…¸ë ¥ì´ í•„ìš”í•˜ë‹¤.

# Copy Program

---

## ver1

---

```cpp
void Copy()
{
 int c;
 while ((c=RdKbd()) != EOF)
 WrtPrt(c);
}
```

## ver2

---

```cpp
bool ptFlag = false;
// remember to reset this flag
void Copy()
{
 int c;
 while ((c=(ptflag ? RdPt() : RdKbd())) != EOF)
 WrtPrt(c);
}
```

## ver3

---

```cpp
bool ptFlag = false;
bool punchFlag = false;
// remember to reset these flags
void Copy()
{
 int c;
 while ((c=(ptflag ? RdPt() : RdKbd())) != EOF)
 punchFlag ? WrtPunch(c) : WrtPrt(c);
}
```

## ver4

---

```cpp
class Reader
{
 public:
 virtual int read() = 0;
};
class KeyboardReader : public Reader
{
 public:
 virtual int read() {return RdKbd();}
};

KeyboardReader GdefaultReader;

void Copy(Reader& reader = GdefaultReader)
{
 int c;
 while ((c=reader.read()) != EOF)
 WrtPrt(c);
}
```

# SRP (Separating Coupled Responsibilities)

---

> í•œ í´ë˜ìŠ¤ëŠ” ë‹¨ í•œ ê°€ì§€ì˜ ë³€ê²½ ì´ìœ ë§Œì„ ê°€ì ¸ì•¼ í•œë‹¤.
> 

## Geometry GUI

---

![Untitled](Principles%20dd0f0cabc14944aaafe27ea6c62652e3/Untitled%201.png)

![Untitled](Principles%20dd0f0cabc14944aaafe27ea6c62652e3/Untitled%202.png)

## Modem Interface

---

```cpp
interface Modem
{
 public void dial(String pno);
 public void hangup();
 public void send(char c);
 public char recv();
}
```

![Untitled](Principles%20dd0f0cabc14944aaafe27ea6c62652e3/Untitled%203.png)

## Persistence

---

![Untitled](Principles%20dd0f0cabc14944aaafe27ea6c62652e3/Untitled%204.png)

# OCP (Open-Closed Pattern)

---

> ì†Œí”„íŠ¸ì›¨ì–´ ê°œì²´(í´ë˜ìŠ¤,ëª¨ë“ˆ,í•¨ìˆ˜ ë“±)ëŠ” í™•ì¥ì— ëŒ€í•´ ì—´ë ¤ ìˆì–´ì•¼ í•˜ê³ , ìˆ˜ì •ì— ëŒ€í•´ì„œëŠ” ë‹«í˜€ìˆì–´ì•¼ í•œë‹¤.
> 

## Strategy Pattern

---

![Untitled](Principles%20dd0f0cabc14944aaafe27ea6c62652e3/Untitled%205.png)

![Untitled](Principles%20dd0f0cabc14944aaafe27ea6c62652e3/Untitled%206.png)

## Template Method Pattern

---

![Untitled](Principles%20dd0f0cabc14944aaafe27ea6c62652e3/Untitled%207.png)

## Shape Class & DrawAllShapes()

---

### 9-1

---

```cpp
--shape.h---------------------------------------
enum ShapeType {circle, square};
struct Shape
{
	ShapeType itsType;
};
--circle.h---------------------------------------
struct Circle
{
	ShapeType itsType;
	double itsRadius;
	Point itsCenter;
};
void DrawCircle(struct Circle*);
--square.h---------------------------------------
struct Square
{
	ShapeType itsType;
	double itsSide;
	Point itsTopLeft;
};
void DrawSquare(struct Square*);
--drawAllShapes.cc-------------------------------
typedef struct Shape *ShapePointer;
void DrawAllShapes(ShapePointer list[], int n)
{
	int i;
	for (i=0; i<n; i++)
	{
		struct Shape* s = list[i];
		switch (s->itsType)
		{
			case square:
				DrawSquare((struct Square*)s);
				break;
			case circle:
				DrawCircle((struct Circle*)s);
				break;
		}
	}
}
```

### 9-2

---

```cpp
class Shape
{
	public:
	virtual void Draw() const = 0;
};
class Square : public Shape
{
	public:
	virtual void Draw() const;
};
class Circle : public Shape
{
	public:
	virtual void Draw() const;
};
void DrawAllShapes(vector<Shape*>& list)
{
	vector<Shape*>::iterator i;
	for (i=list.begin(); i != list.end(); i++)
		(*i)->Draw();
}
```

### 9-3,4,5

---

```cpp
class Shape
{
	public:
		virtual void Draw() const = 0;
		virtual bool Precedes(const Shape&) const = 0;
		bool operator<(const Shape& s) {return Precedes(s);}
};
```

```cpp
template <typename P>
class Lessp // utility for sorting containers of pointers.
{
	public:
	bool operator()(const P p, const P q) {return (*p) < (*q);}
};
void DrawAllShapes(vector<Shape*>& list)
{
	vector<Shape*> orderedList = list;
	sort(orderedList.begin(),	orderedList.end(),	Lessp<Shape*>());
	vector<Shape*>::const_iterator i;
	for (i=orderedList.begin(); i != orderedList.end(); i++)
		(*i)->Draw();
}
```

```cpp
bool Circle::Precedes(const Shape& s) const
{
	if (dynamic_cast<Square*>(s))
		return true;
	else
		return false;
}
```

### 9-6

---

```cpp
#include <typeinfo>
#include <string>
#include <iostream>

using namespace std;

class Shape
{
	public:
		virtual void Draw() const = 0;
		bool Precedes(const Shape&) const;
		bool operator<(const Shape& s) const
		{return Precedes(s);}
	private:
		static const char* typeOrderTable[];
};

const char* Shape::typeOrderTable[] =
{
	typeid(Circle).name(),
	typeid(Square).name(),
	0
};

// This function searches a table for the class names.
// The table defines the order in which the
// shapes are to be drawn. Shapes that are not
// found always precede shapes that are found.
//
bool Shape::Precedes(const Shape& s) const
{
	const char* thisType = typeid(*this).name();
	const char* argType = typeid(s).name();
	bool done = false;
	int thisOrd = -1;
	int argOrd = -1;
	for (int i=0; !done; i++)
	{
		const char* tableEntry = typeOrderTable[i];
		if (tableEntry != 0)
		{
			if (strcmp(tableEntry, thisType) == 0)
				thisOrd = i;
			if (strcmp(tableEntry, argType) == 0)
				argOrd = i;
			if ((argOrd >= 0) && (thisOrd >= 0))
				done = true;
		}
		else // table entry == 0
			done = true;
	}
	return thisOrd < argOrd;
}
```

# LSP (Liskov Substitution Principle)

---

> ì„œë¸Œíƒ€ì…(subtype)ì€ ê·¸ê²ƒì˜ ê¸°ë°˜ íƒ€ì…(base type)ìœ¼ë¡œ ì¹˜í™˜ ê°€ëŠ¥í•´ì•¼í•œë‹¤.
> 

> íƒ€ì… Sì˜ ê° ê°ì²´ o1ê³¼ íƒ€ì… Tì˜ ê° ê°ì²´ o2 ê°€ ìˆì„ ë•Œ, Të¡œ í”„ë¡œê·¸ë¨ Pë¥¼ ì •ì˜í–ˆìŒì—ë„ ë¶ˆêµ¬í•˜ê³  o2ë¥¼ o1ìœ¼ë¡œ ì¹˜í™˜í•˜ì—¬ë„ Pì˜ í–‰ìœ„ê°€ ë³€í•˜ì§€ ì•Šìœ¼ë©´, SëŠ” Tì˜ ì„œë¸Œíƒ€ì…ì´ë‹¤
> 

## LSPìœ„ë°˜ì€ ê³§ OCPìœ„ë°˜ì´ë‹¤

---

### 10-1

---

```cpp
struct Point {double x,y;};
struct Shape {
	enum ShapeType {square, circle} itsType;
	Shape(ShapeType t) : itsType(t) {}
};
struct Circle : public Shape
{
	Circle() : Shape(circle) {};
	void Draw() const;
	Point itsCenter;
	double itsRadius;
};
struct Square : public Shape
{
	Square() : Shape(square) {};
	void Draw() const;
	Point itsTopLeft;
	double itsSide;
};
void DrawShape(const Shape& s)
{
	if (s.itsType == Shape::square)
		static_cast<const Square&>(s).Draw();
	else if (s.itsType == Shape::circle)
		static_cast<const Circle&>(s).Draw();
}
```

## Rect Class & Square Class

---

![Untitled](Principles%20dd0f0cabc14944aaafe27ea6c62652e3/Untitled%208.png)

### 10-2 & f()

---

```cpp
class Rectangle
{
	public:
		void SetWidth(double w) {itsWidth=w;}
		void SetHeight(double h) {itsHeight=w;}
		double GetHeight() const {return itsHeight;}
		double GetWidth() const {return itsWidth;}
	private:
		Point itsTopLeft;
		double itsWidth;
		double itsHeight;
};

void Square::SetWidth(double w)
{
	Rectangle::SetWidth(w);
	Rectangle::SetHeight(w);
}
void Square::SetHeight(double h)
{
	Rectangle::SetHeight(h);
	Rectangle::SetWidth(h);
}

Square s;
s.SetWidth(1); // Fortunately sets the height to 1 too.
s.SetHeight(2); // sets width and height to 2. Good thing.
```

```cpp
void f(Rectangle& r)
{
	r.SetWidth(32); // calls Rectangle::SetWidth
}
```

### 10-3 & g()

---

```cpp
class Rectangle
{
	public:
		virtual void SetWidth(double w) {itsWidth=w;}
		virtual void SetHeight(double h) {itsHeight=h;}
		double GetHeight() const {return itsHeight;}
		double GetWidth() const {return itsWidth;}
		private:
		Point itsTopLeft
		double itsHeight;
		double itsWidth;
};
class Square : public Rectangle
{
	public:
		virtual void SetWidth(double w);
		virtual void SetHeight(double h);
};
void Square::SetWidth(double w)
{
	Rectangle::SetWidth(w);
	Rectangle::SetHeight(w);
}
void Square::SetHeight(double h)
{
	Rectangle::SetHeight(h);
	Rectangle::SetWidth(h);
}
```

```cpp
void g(Rectangle& r)
{
	r.SetWidth(5);
	r.SetHeight(4);
	assert(r.Area() == 20);
}
```

## DBC(Design By Contract)

---

### DBCë¥¼ ì‚¬ìš©í•˜ë©´â€¦

- ì‚¬ìš©ìëŠ” í´ë˜ìŠ¤ì˜ ê³„ì•½ ì‚¬í•­ì„ ëª…ì‹œì ìœ¼ë¡œ ì„¤ì •.
- ì´ í´ë˜ìŠ¤ë¥¼ ì‚¬ìš©í•˜ëŠ” ì‘ì„±ìê°€ ì‹ ë¢°í•  ìˆ˜ ìˆëŠ” í–‰ìœ„ì— ëŒ€í•´ì„œ ì•Œë ¤ì¤Œ.
- ê° ë©”ì†Œë“œì˜ ì‚¬ì „ì¡°ê±´ê³¼ ì‚¬í›„ì¡°ê±´ì„ ì„ ì–¸í•˜ëŠ” ê²ƒìœ¼ë¡œ ê³„ì•½ì„ êµ¬ì²´í™”ë¨.
- ë©”ì†Œë“œë¥¼ ì‹¤í–‰í•˜ê¸° ìœ„í•´ì„œëŠ” ì‚¬ì „ì¡°ê±´ì´ ì°¸ì´ ë˜ì–´ì•¼ í•¨.
- ë©”ì†Œë“œëŠ” ì™„ë£Œë˜ë©´ ì‚¬í›„ì¡°ê±´ì´ ì°¸ì´ ë¨ì„ ë³´ì¥í•¨.

### íŒŒìƒ í¬ë˜ìŠ¤ ì‚¬ì „ì¡°ê±´,ì‚¬í›„ì¡°ê±´ ê·œì¹™

> â€œíŒŒìƒ í´ë˜ìŠ¤ì—ì„œ ë£¨í‹´ ì¬ì„ ì–¸ì€ ì˜¤ì§ ì›ë˜ì˜ ì‚¬ì „ì¡°ê±´ê³¼ ê°™ê±°ë‚˜ ë” ì•½í•œ ìˆ˜ì¤€ì—ì„œ ê·¸ê²ƒì„ ëŒ€ì²´
í•  ìˆ˜ ìˆê³ , ì›ë˜ì˜ ì‚¬í›„ì¡°ê±´ê³¼ ê°™ê±°ë‚˜ ë” ê°•í•œìˆ˜ì¤€ì—ì„œ ê·¸ê²ƒì„ ëŒ€ì²´í•  ìˆ˜ ìˆë‹¤
> 
- íŒŒìƒëœ ê°ì²´ëŠ” ê¸°ë°˜ í´ë˜ìŠ¤ê°€ ë°›ì•„ë“¤ì¼ ìˆ˜ ìˆëŠ”ê²ƒì€ ëª¨ë‘ ë°›ì•„ë“¤ì—¬ì•¼ í•œë‹¤. (íŒŒìƒí´ë˜ìŠ¤ì˜ ì‚¬ì „
ì¡°ê±´ì€ ê¸°ë°˜í´ë˜ìŠ¤ì˜ ì‚¬ì „ì¡°ê±´ë³´ë‹¤ ì•½í•˜ë‹¤.)
- íŒŒìƒ í´ë˜ìŠ¤ëŠ” ê¸°ë°˜ í´ë˜ìŠ¤ì˜ ëª¨ë“  ì‚¬í›„ì¡°ê±´ì„ ë”°ë¼ì•¼ í•œë‹¤. (íŒŒìƒí´ë˜ìŠ¤ì˜ ì‚¬í›„ì¡°ê±´ì€ ê¸°ë°˜ í´
ë˜ìŠ¤ì˜ ì‚¬í›„ì¡°ê±´ë³´ë‹¤ ê°•í•˜ë‹¤.)

### DBCì— ì˜í•˜ë©´ Rectangle, SquareëŠ”â€¦

**Rectangle::SetWidth(double w)**

```cpp
assert((itsWidth == w) && (itsHeight == old.itsHeight));
```

**Square::SetWidth(double w)**

```cpp
assert(itsWidth == w);

```

- (itsHeight == old.itsHeight) ì¡°ê±´ì„ ê°•ì œí•˜ì§€ ì•ŠìŒ.
- ì‚¬í›„ì¡°ê±´ì´ ë” ì•½í•¨ â†’ ê³„ì•½ ìœ„ë°˜
- (itsWidth == itsHeight) â†’ (itsHeight == old.itsHeight)ê³¼ ì¶©ëŒ